{"ast":null,"code":"'use strict';\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js');\n\nvar codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous: previous\n};\n\nfunction resolveCodeText(events) {\n  var tailExitIndex = events.length - 4;\n  var headEnterIndex = 3;\n  var index;\n  var enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = events[headEnterIndex][1].type = 'codeTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\n      events[enter][1].type = 'codeTextData';\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 96 || this.events[this.events.length - 1][1].type === 'characterEscape';\n}\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  var sizeOpen = 0;\n  var size;\n  var token;\n  return start;\n\n  function start(code) {\n    effects.enter('codeText');\n    effects.enter('codeTextSequence');\n    return openingSequence(code);\n  }\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code);\n      sizeOpen++;\n      return openingSequence;\n    }\n\n    effects.exit('codeTextSequence');\n    return gap(code);\n  }\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code);\n    } // Closing fence?\n    // Could also be data.\n\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence');\n      size = 0;\n      return closingSequence(code);\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n    if (code === 32) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return gap;\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return gap;\n    } // Data.\n\n\n    effects.enter('codeTextData');\n    return data(code);\n  } // In code.\n\n\n  function data(code) {\n    if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {\n      effects.exit('codeTextData');\n      return gap(code);\n    }\n\n    effects.consume(code);\n    return data;\n  } // Closing fence.\n\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code);\n      size++;\n      return closingSequence;\n    } // Done!\n\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence');\n      effects.exit('codeText');\n      return ok(code);\n    } // More or less accents: mark as data.\n\n\n    token.type = 'codeTextData';\n    return data(code);\n  }\n}\n\nmodule.exports = codeText;","map":{"version":3,"names":["markdownLineEnding","require","codeText","name","tokenize","tokenizeCodeText","resolve","resolveCodeText","previous","events","tailExitIndex","length","headEnterIndex","index","enter","type","undefined","end","splice","code","effects","ok","nok","sizeOpen","size","token","start","openingSequence","consume","exit","gap","closingSequence","data","module","exports"],"sources":["/Users/zhangruikai/Desktop/rudyzhang123.github.io/node_modules/micromark/dist/tokenize/code-text.js"],"sourcesContent":["'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\n\nvar codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous: previous\n}\n\nfunction resolveCodeText(events) {\n  var tailExitIndex = events.length - 4\n  var headEnterIndex = 3\n  var index\n  var enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = events[headEnterIndex][1].type =\n          'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  var sizeOpen = 0\n  var size\n  var token\n  return start\n\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return openingSequence(code)\n  }\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('codeTextSequence')\n    return gap(code)\n  }\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return closingSequence(code)\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    } // Data.\n\n    effects.enter('codeTextData')\n    return data(code)\n  } // In code.\n\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  } // Closing fence.\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n\nmodule.exports = codeText\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}