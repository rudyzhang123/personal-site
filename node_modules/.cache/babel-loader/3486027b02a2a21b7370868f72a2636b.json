{"ast":null,"code":"\"use strict\";\n/**\n * Naive, simple plugin to match inline nodes without attributes\n * This allows say <strong>foo</strong>, but not <strong class=\"very\">foo</strong>\n * For proper HTML support, you'll want a different plugin\n **/\n\nvar visit = require('unist-util-visit');\n\nvar type = 'virtualHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar simpleTagRe = /^<(\\/?)([a-z]+)\\s*>$/;\n\nmodule.exports = function (tree) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosing(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: type,\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = getSimpleTag(node, parent);\n\n    if (!current) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, virtual(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  );\n  return tree;\n};\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction getSimpleTag(node, parent) {\n  var match = node.value.match(simpleTagRe);\n  return match ? {\n    tag: match[2],\n    opening: !match[1],\n    node: node\n  } : false;\n}\n\nfunction getSelfClosing(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction virtual(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}","map":{"version":3,"names":["visit","require","type","selfClosingRe","simpleTagRe","module","exports","tree","open","currentParent","node","index","parent","selfClosing","getSelfClosing","children","splice","tag","position","current","getSimpleTag","matching","findAndPull","virtual","opening","push","matchingTag","i","length","match","value","fromNode","toNode","fromIndex","indexOf","toIndex","extracted","slice","start","end","indent"],"sources":["/Users/zhangruikai/Desktop/rudyzhang123.github.io/node_modules/react-markdown/lib/plugins/naive-html.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Naive, simple plugin to match inline nodes without attributes\n * This allows say <strong>foo</strong>, but not <strong class=\"very\">foo</strong>\n * For proper HTML support, you'll want a different plugin\n **/\nvar visit = require('unist-util-visit');\n\nvar type = 'virtualHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar simpleTagRe = /^<(\\/?)([a-z]+)\\s*>$/;\n\nmodule.exports = function (tree) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosing(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: type,\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = getSimpleTag(node, parent);\n\n    if (!current) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, virtual(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  );\n  return tree;\n};\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction getSimpleTag(node, parent) {\n  var match = node.value.match(simpleTagRe);\n  return match ? {\n    tag: match[2],\n    opening: !match[1],\n    node: node\n  } : false;\n}\n\nfunction getSelfClosing(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction virtual(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}