{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar assign = require('../constant/assign.js');\n\nvar shallow = require('../util/shallow.js');\n\nvar text = initializeFactory('text');\nvar string = initializeFactory('string');\nvar resolver = {\n  resolveAll: createResolver()\n};\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined)\n  };\n\n  function initializeText(effects) {\n    var self = this;\n    var constructs = this.parser.constructs[field];\n    var text = effects.attempt(constructs, start, notText);\n    return start;\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n\n      effects.enter('data');\n      effects.consume(code);\n      return data;\n    }\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data');\n        return text(code);\n      } // Data.\n\n\n      effects.consume(code);\n      return data;\n    }\n\n    function atBreak(code) {\n      var list = constructs[code];\n      var index = -1;\n\n      if (code === null) {\n        return true;\n      }\n\n      if (list) {\n        while (++index < list.length) {\n          if (!list[index].previous || list[index].previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n\n  function resolveAllText(events, context) {\n    var index = -1;\n    var enter; // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n\n        enter = undefined;\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n} // A rather ugly set of instructions which again looks at chunks in the input\n// stream.\n// The reason to do this here is that it is *much* faster to parse in reverse.\n// And that we can’t hook into `null` to split the line suffix before an EOF.\n// To do: figure out if we can make this into a clean utility, or even in core.\n// As it will be useful for GFMs literal autolink extension (and maybe even\n// tables?)\n\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = -1;\n  var chunks;\n  var data;\n  var chunk;\n  var index;\n  var bufferIndex;\n  var size;\n  var tabs;\n  var token;\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') && events[eventIndex - 1][1].type === 'data') {\n      data = events[eventIndex - 1][1];\n      chunks = context.sliceStream(data);\n      index = chunks.length;\n      bufferIndex = -1;\n      size = 0;\n      tabs = undefined;\n\n      while (index--) {\n        chunk = chunks[index];\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        } // Number\n        else if (chunk === -2) {\n          tabs = true;\n          size++;\n        } else if (chunk === -1) ;else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      }\n\n      if (size) {\n        token = {\n          type: eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\n          },\n          end: shallow(data.end)\n        };\n        data.end = shallow(token.start);\n\n        if (data.start.offset === data.end.offset) {\n          assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n\n      eventIndex++;\n    }\n  }\n\n  return events;\n}\n\nexports.resolver = resolver;\nexports.string = string;\nexports.text = text;","map":{"version":3,"names":["Object","defineProperty","exports","value","assign","require","shallow","text","initializeFactory","string","resolver","resolveAll","createResolver","field","tokenize","initializeText","resolveAllLineSuffixes","undefined","effects","self","constructs","parser","attempt","start","notText","code","atBreak","consume","enter","data","exit","list","index","length","previous","call","extraResolver","resolveAllText","events","context","type","end","splice","eventIndex","chunks","chunk","bufferIndex","size","tabs","token","sliceStream","charCodeAt","line","column","offset","_index","_bufferIndex"],"sources":["/Users/zhangruikai/Desktop/rudyzhang123.github.io/node_modules/micromark/dist/initialize/text.js"],"sourcesContent":["'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar assign = require('../constant/assign.js')\nvar shallow = require('../util/shallow.js')\n\nvar text = initializeFactory('text')\nvar string = initializeFactory('string')\nvar resolver = {\n  resolveAll: createResolver()\n}\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n\n  function initializeText(effects) {\n    var self = this\n    var constructs = this.parser.constructs[field]\n    var text = effects.attempt(constructs, start, notText)\n    return start\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      } // Data.\n\n      effects.consume(code)\n      return data\n    }\n\n    function atBreak(code) {\n      var list = constructs[code]\n      var index = -1\n\n      if (code === null) {\n        return true\n      }\n\n      if (list) {\n        while (++index < list.length) {\n          if (\n            !list[index].previous ||\n            list[index].previous.call(self, self.previous)\n          ) {\n            return true\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  function resolveAllText(events, context) {\n    var index = -1\n    var enter // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n} // A rather ugly set of instructions which again looks at chunks in the input\n// stream.\n// The reason to do this here is that it is *much* faster to parse in reverse.\n// And that we can’t hook into `null` to split the line suffix before an EOF.\n// To do: figure out if we can make this into a clean utility, or even in core.\n// As it will be useful for GFMs literal autolink extension (and maybe even\n// tables?)\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = -1\n  var chunks\n  var data\n  var chunk\n  var index\n  var bufferIndex\n  var size\n  var tabs\n  var token\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      data = events[eventIndex - 1][1]\n      chunks = context.sliceStream(data)\n      index = chunks.length\n      bufferIndex = -1\n      size = 0\n      tabs = undefined\n\n      while (index--) {\n        chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        } // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1);\n        else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      if (size) {\n        token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: shallow(data.end)\n        }\n        data.end = shallow(token.start)\n\n        if (data.start.offset === data.end.offset) {\n          assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n\nexports.resolver = resolver\nexports.string = string\nexports.text = text\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}